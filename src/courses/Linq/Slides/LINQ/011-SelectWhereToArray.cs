using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;

namespace uLearn.Courses.Linq.Slides
{
	[Slide("Фильтрация и преобразование", "{E0114584-4500-40B2-B6D6-DB8AF455978B}")]
	public class SelectWhereToArray
	{
		/*
		В основе `LINQ` лежит интерфейс __последовательности__ `IEnumerable<T>`. 
		Последовательность — это абстракция чего-то, что можно начать перечислять, 
		и переходить от текущего элемента к следующему пока последовательность не закончится.

		Массивы, `List`, `Dictionary`, `HashSet` — все эти коллекции реализуют интерфейс последовательности.

		Для `IEnumerable` в пространстве имен `System.Linq` определено множество полезных методов расширений.
		Они и образуют основу `LINQ`.
		
		Начнем знакомство с самыми основными.

		## Методы фильтрации и преобразования

		`Where` используется для фильтрации перечисляемого. Он принимает в качестве параметра функцию-предикат 
		и возвращает новое перечисляемое, состоящее только из тех элементов исходного перечисляемого, на которых предикат вернул `true`.
		
		Вот его полная сигнатура:

		`IEnumerable<T> Where(this IEnumerable<T> items, Func<T, bool> predicate)`

		`Select` используется для поэлементного преобразования перечисляемого. Он принимает в качестве параметра преобразующую функцию 
		и возвращает новое перечисляемое, полученное применением этой функции к каждому элементу исходного перечисляемого.
		
		`IEnumerable<R> Select(this IEnumerable<T> items, Func<T, R> map)`
		
		Тут самое время ещё раз взглянуть на пример с первого слайда — его логика должна проясниться:
		*/

		[HideOnSlide]
		private readonly Intro.Letter[] letters = new Intro.Letter[0];

		public IEnumerable<int> GetNewLettersIds()
		{
			return letters.Where(l => l.IsNew).Select(l => l.Id);
		}
	}
}