using uLearn;

namespace OOP.Slides.U03_DataStructure
{
	[Slide("Ассоциативный массив", "{FDE53EE1-29BA-41FB-BADE-9DACB7495B42}")]
	public class S010_AssociativeArray
	{
		/*
		Напомним основные факты про ассоциативные массивы (они же словари, они же Map, они же Dictionary).

		Ассоциативный массив — абстрактный тип данных для хранения пары (ключ, значение), поддерживающий операции добавления пары, поиска и удаления пары по ключу:

		* put(ключ, значение)
		* get(ключ)
		* remove(ключ)

		Предполагается, что ассоциативный массив не может хранить две пары с одинаковыми ключами.

		### Реализация
		При реализации структуры данных анализируют временную сложность операций и пространственную сложность самой структуры. 
		Для ассоциативного массива для всех рассматриваемых реализаций количество занимаемого места пропорционально количеству элементов — $O(N)$. А временные сложности операций зависят от реализации.

		#### Тривиальная реализация
		Самая тривиальная реализация ассоциативного массива — это список пар.

		Временную сложность операций такой реализации:

		* put — в среднем $O(1)$, в худшем $O(N)$.
		* get — $O(N)$, так как для нахождения пары (ключ-значение) необходимо пройти весь массив проверяя каждую пару на равенство ключей.
		* remove — $O(N)$, так как для удаления элемента необходимо сначала найти удаляемую пару за $O(N)$, а затем удалить элемент из динамического массива за $O(N)$. 

		Проблемой данной реализация является неэффективность операций get и remove.

		#### Хеш-таблица
		Одним из способов эффективной реализации ассоциативного массива является хэш-таблица. С подробностями реализации можно ознакомиться [в википедии](https://en.wikipedia.org/wiki/Hash_table). 
		Важно отметить сложность операций: для всех трех операций — $O(1)$ в среднем.

		#### Балансирующиеся двоичные деревья поиска

		Другим эффективным способом реализации является балансирующиеся двоичные деревья поиска. 
		С тем, что такое бинарное дерево поиска можно ознакомиться [в википедии](https://en.wikipedia.org/wiki/Binary_search_tree).

		Отметим самые известные алгоритмы балансировки:

		* [AVL дерево](https://ru.wikipedia.org/wiki/%D0%90%D0%92%D0%9B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
		* [Декартово дерево](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
		* [Красно-черное дерево](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)

		Сложность всех операций пропорциональна высоте дерева, а значит в сбалансированном дереве — $O(\log N)$. 
		
		Таким образом деревья медленнее хэш-таблиц, однако они сохраняют ключи упорядоченными. 
		Это позволяет быстро выполнять некоторые операции, недоступные хэш-таблицам — поиск минимума / максимума, поиск всех ключей из диапазона и т.п.

		#### Список с пропусками
		
		Другой интересной альтернативой деревьям поиска является [список с пропусками](http://en.wikipedia.org/wiki/Skip_list).
		При желании можете изучить эту структуру данных самостоятельно.
		*/

	}
}