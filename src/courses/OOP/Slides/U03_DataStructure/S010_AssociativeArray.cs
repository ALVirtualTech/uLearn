using uLearn;

namespace OOP.Slides.U03_DataStructure
{
	[Slide("Ассоциативный массив", "{FDE53EE1-29BA-41FB-BADE-9DACB7495B42}")]
	public class S010_AssociativeArray
	{
        /*
        Ассоциативный массив (словарь, карта) — абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу:
        * INSERT(ключ, значение)
        * FIND(ключ)
        * REMOVE(ключ)
        Предполагается, что ассоциативный массив не может хранить две пары с одинаковыми ключами.
        
        ### Реализация
        При реализация какой-либо операции как правило пытаются оценивать некоторые ее свойства. Например: сколько места она занимает и какова ассимптотическая сложность операций. 
        Для ассоциативного массива для всех рассматриваемых реализаций количество занимаемого места пропорционально количеству элементов - O(N). 
        
        #### Тривиальная реализация
        Самая тривиальная реализация ассоциативного массива - это динамический массив(https://en.wikipedia.org/wiki/Dynamic_array), элементами которого является пара из (ключ-значение). 
        Оценим сложность операций:
        * INSERT - сложность данной операции равна сложности добавления элемента в конец динимаческого массива - в среднем O(1). 
        * FIND - для нахождения пары(ключ-значение) необходимо пройти весь массив проверяя каждую пару на равенство ключей - O(N)
        * REMOVE - для удаления элемента необходимо сначала найти удаляемую пару - $O(N)$, а затем удалить элемент из динамического массива - O(N). 
        Проблемой данной реализация является неэффективность операций FIND и REMOVE. Далее будут предложены альтернативные реализации улучшающие ассимтотику данных операций.
        
        #### Хеш-таблица
        Одним из способов эффективной реализации ассоциативного массива является хеш-таблица. С подробностями реализации можно ознакомиться в википедии(https://en.wikipedia.org/wiki/Hash_table). 
        Важно отметить сложность операций: для всех трех операций - $O(1)$ в среднем.
        
        #### Самобалансирующиеся двоичные деревья поиска
        Другим эффективным способом реализации является самобалансирующиеся двоичные деревья поиска. С тем, что такое бинарное дерево поиска можно ознакомиться в википедии(https://en.wikipedia.org/wiki/Binary_search_tree).
        Отметим самые известные алгоритмы балансировки:
        * АВЛ дерево
        * Декартово дерево
        * Красно-черное дерево
        Так же стоит отметить сложность операций: для всех трех операций - $O(\log N)$. 
        Особенностью реализации с помощью деревьев поиска в отличии от хеш-таблицы является то, что данная реализация сохраняет ключи упорядоченными.
        
        #### Список с пропусками
        Другой интересной альтернативой деревьям поиска является список с пропусками(http://en.wikipedia.org/wiki/Skip_list). 
        */

    }
}