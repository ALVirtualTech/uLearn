# Аудиторные практики

0. Предупредить о контрольной на следующей паре. Тема контрольной — алгоритмы с массивами и оценка сложности таких алгоритмов.

1. Дан массив чисел X. Нужно его сдвинуть циклически на K вправо.

	Обсудить сложность наивного решения с K сдвигами на единичку.

	Решение.

	Есть красивое решение с тремя переворотами. 
	Пусть `Reverse(X, firstIndex, count)` переворачивает участок массива X размера count начиная с индекса firstIndex.
	Тогда вот решение: `Reverse(Reverse(Reverse(X, N-K, K), 0, N-K) 0, N)`

2. Оценить сложность наивного алгоритма поиска подстроки в строке.

3. Оценить сложность двойного цикла с разными хитрыми ограничениями и инкрементом. O(n^2)

		for(int i=0; i<n; i+=2)
			for(int j=i; j<n-i; j++)
				sum++;

4. Оценить сложность двойного цикла с удвоением вместо инкремента. O(n log n)

		for(int i=0; i<n; i++)
			for(int j=0; j<n; j*=2)
				sum++;



5. __Для сильных групп__. "Корневой сумматор". Пусть дан массив чисел A длины N. 
	Нужно уметь отвечать на запросы вида "какова сумма элементов с i по j?"
	Можно использовать o-малое(N) дополнительной памяти и потратить O(N) времени на подготовку к обработке запросов.
	Отвечать на запрос нужно за о-малое(N).

	* Обсудить сложность тривиального решения. (O(N) на каждый запрос)
	* Обсудить решение, без ограничения о-малое(N) на дополнительную память. 
	(Посчитаем заранее все частичные суммы A и будем отвечать на запросы за O(1))
	* Обсудить, какие бывают функции о-малое(N) (логарифм, корень, константа)

	Решение:

	Разбить массив на sqrt(N) групп, и заранее подсчитать суммы в этих группах и сохранить в дополнительном массиве.
	Тогда для ответа на запрос придется найти все группы, которые целиком попали в диапазон (за O(sqrt(N)) 
	и добавить к ним сумму левого и правого хвоста, (в каждом менее sqrt(N) элементов).
	Итого, сложность O(3*sqrt(N))

	При объяснении лучше, чтобы корень появился в самом конце. Отталкиваться можно от идеи "разобьем на несколько частей".
	А уже в конце посчитать на сколько частей бить оптимальнее всего.

